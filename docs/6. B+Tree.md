# B+ Tree

## What

Self-balancing data structure that maintains sorted data. What this: https://www.youtube.com/watch?v=c8YdjrnyKvc

## Why

- Redis default use Hash Table (dict) for key-value store -> lookup only cost O(1). However, it don't support range query effectively (have to scan entirely)
- B Tree or B+ Tree ([watch this](https://www.youtube.com/watch?v=JWSObwhGGxY))

  ![alt text](image-51.png)

  | Aspect            | B-Tree                           | B+ Tree                              |
  | ----------------- | -------------------------------- | ------------------------------------ |
  | Where data stored | Internal + leaf nodes            | Leaf nodes only                      |
  | Traversal         | Must visit internal + leaf nodes | Sequential leaf links, easy scanning |
  | Search depth      | Variable (may stop at internal)  | Consistent (always reach leaf)       |
  | Range queries     | Slower                           | Faster (linked leaves)               |
  | Space efficiency  | Lower (values in internal nodes) | Higher (keys only in internal nodes) |
  | Fan-out           | Lower                            | Higher (smaller internal nodes)      |

  - **Data storage**:
    - **B Tree**: Store keys and values both in internal and leaf nodes.
    - **B+ Tree**: Store keys in internal nodes, key-value in leaf nodes.
  - **Traversal**:
    - **B Tree**: Traversal visits both internal and leaf nodes to access data.
    - **B+ Tree**: Traversal uses linked leaves, enabling efficient range queries.
  - **Search Performance**:
    - **B Tree**: Search may stop at an internal node.
    - **B+ Tree**: Search always goes to a leaf, providing consistent depth.
  - **Range queries**:
    - **B Tree**: Range queries are slower because internal nodes are not sequentially linked.
    - **B+ Tree**: Range queries are fast because leaf nodes are linked.
  - **Space utilization**:
    - **B Tree**: Internal nodes store both keys and values, reducing fan-out (maximum number of child node, higher is better).
    - **B+ Tree**: Internal nodes store only keys, increasing fan-out and reducing tree height.

### Pros

- **Low height**: Each node have high order. Height of B+ Tree is sallow, thus minimize disk access.
- **All data sorted in leaves**: Leaf nodes are linked together in a list. Enables fast range scan (for example, retrieving all key within [a, b])
- **Automatic balancing on updates**: Insert and delete operations rebalance the tree automatically. Queries always run in O(log n)
- **Optimized for disk and memory blocks**: Node sizes are typically aligned with page or block sizes (for example, 4 KB). Maximizes locality when loading from disk or cache.
- **Lower memory overhead**: Use less memory than Skip List (e.g. DragonFly use)

### Cons

- **Higher update cost compared to hash tables**: Insert and delete operations may require splitting or merging nodes.
- **Slower exact key lookup compared to hash tables**: Hash table lookups run in O(1), while B+ trees require O(log n).
- **Extra memory usage**: Nodes must store multiple pointers, which increases overhead.

## How

![alt text](image-41.png)
Rule:

- Number of key = number of children - 1
- Each node must have at least [order / 2] children

- Insertion:

  - Normatl Insert:

    - Before:
      ![alt text](image-42.png)
    - After:
      ![alt text](image-43.png)

  - Insert when node is full (except root)

    - Before:
      ![alt text](image-44.png)
    - After:
      ![alt text](image-45.png)

  - Insert when root is full
    - Before:
    ```less
                    [ 9 | 12 | 20 ]
               /      |      |       \
        [3, 6]   [9, 10]  [14, 18]  [20, 30, 40]
    ```
    - After:
    ```less
                      [ 20 ]
                   /        \
             [ 9 | 12 ]     [ 40 ]
            /    |    \     /     \
      [3,6] [9,10] [14,18] [20,30] [40,50]
    ```

- Deletion:

  - Before:
    ![alt text](image-46.png)

  - After:
    ![alt text](image-47.png)
